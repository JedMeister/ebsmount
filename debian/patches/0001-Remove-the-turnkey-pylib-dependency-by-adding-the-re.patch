From: Roy Liu <carsomyr@gmail.com>
Date: Wed, 28 Nov 2012 23:24:42 -0500
Subject: Remove the turnkey-pylib dependency by adding the requisite Python
 imports

---
 conffile.py | 98 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 executil.py | 96 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 194 insertions(+)
 create mode 100644 conffile.py
 create mode 100644 executil.py

diff --git a/conffile.py b/conffile.py
new file mode 100644
index 0000000..6272634
--- /dev/null
+++ b/conffile.py
@@ -0,0 +1,98 @@
+# Copyright (c) 2010 Alon Swartz <alon@turnkeylinux.org>
+#
+# This file is part of turnkey-pylib.
+#
+# turnkey-pylib is open source software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 3 of the
+# License, or (at your option) any later version.
+
+import os
+
+class ConfFileError(Exception):
+    pass
+
+class ConfFile(dict):
+    """Configuration file class (targeted at simple shell type configs)
+
+    Usage:
+
+        class foo(ConfFile):
+            CONF_FILE = /path/to/conf
+            REQUIRED = ['arg1' ,'arg2']
+
+        conf = foo()
+        print conf.arg1     # display ARG1 value from /path/to/conf
+        conf.arg2 = value   # set ARG2 value
+        conf.write()        # write new/update config to /path/to/conf
+
+    Format:
+
+        # comments are ignored
+        NAME=alon
+        AGE=29
+
+    """
+    CONF_FILE = None
+    REQUIRED = []
+    SET_ENVIRON = False
+
+    def __init__(self):
+        self.read()
+        self.validate_required()
+        if self.SET_ENVIRON:
+            self.set_environ()
+
+    def validate_required(self, required=[]):
+        """raise exception if required arguments are not set
+        REQUIRED validated by default, but can be optionally extended
+        """
+        self.REQUIRED.extend(required)
+        for attr in self.REQUIRED:
+            if not self.has_key(attr):
+                error = "%s not specified in %s" % (attr.upper(), self.CONF_FILE)
+                raise ConfFileError(error)
+
+    def set_environ(self):
+        """set environment (run on initialization if SET_ENVIRON)"""
+        for key, val in self.items():
+            os.environ[key.upper()] = val
+
+    def read(self):
+        if not self.CONF_FILE or not os.path.exists(self.CONF_FILE):
+            return 
+
+        for line in file(self.CONF_FILE).readlines():
+            line = line.rstrip()
+
+            if not line or line.startswith("#"):
+                continue
+
+            key, val = line.split("=")
+            self[key.strip().lower()] = val.strip()
+
+    def write(self):
+        fh = file(self.CONF_FILE, "w")
+        items = self.items()
+        items.sort()
+        for key, val in items:
+            print >> fh, "%s=%s" % (key.upper(), val)
+
+        fh.close()
+
+    def items(self):
+        items = []
+        for key in self:
+            items.append((key, self[key]))
+
+        return items
+
+    def __getattr__(self, key):
+        try:
+            return self[key]
+        except KeyError, e:
+            raise AttributeError(e)
+
+    def __setattr__(self, key, val):
+        self[key] = val
+
diff --git a/executil.py b/executil.py
new file mode 100644
index 0000000..e879a60
--- /dev/null
+++ b/executil.py
@@ -0,0 +1,96 @@
+# Copyright (c) 2010 Liraz Siri <liraz@turnkeylinux.org>
+#
+# This file is part of turnkey-pylib.
+#
+# turnkey-pylib is open source software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 3 of the
+# License, or (at your option) any later version.
+"""
+This module contains high-level convenience functions for safe
+command execution that properly escape arguments and raise an
+ExecError exception on error
+"""
+import os
+import sys
+import commands
+
+from subprocess import Popen, PIPE
+
+mkarg = commands.mkarg
+
+class ExecError(Exception):
+    """Accessible attributes:
+    command	executed command
+    exitcode	non-zero exitcode returned by command
+    output	error output returned by command
+    """
+    def __init__(self, command, exitcode, output=None):
+        Exception.__init__(self, command, exitcode, output)
+
+        self.command = command
+        self.exitcode = exitcode
+        self.output = output
+
+    def __str__(self):
+        str = "non-zero exitcode (%d) for command: %s" % (self.exitcode,
+                                                          self.command)
+        if self.output:
+            str += "\n" + self.output
+        return str
+
+def fmt_command(command, *args):
+    return command + " ".join([mkarg(arg) for arg in args])
+
+def system(command, *args):
+    """Executes <command> with <*args> -> None
+    If command returns non-zero exitcode raises ExecError"""
+
+    sys.stdout.flush()
+    sys.stderr.flush()
+
+    command = fmt_command(command, *args)
+    error = os.system(command)
+    if error:
+        exitcode = os.WEXITSTATUS(error)
+        raise ExecError(command, exitcode)
+
+def getoutput(command, *args):
+    """Executes <command> with <*args> -> output
+    If command returns non-zero exitcode raises ExecError"""
+
+    command = fmt_command(command, *args)
+    error, output = commands.getstatusoutput(command)
+    if error:
+        exitcode = os.WEXITSTATUS(error)
+        raise ExecError(command, exitcode, output)
+
+    return output
+
+def getoutput_popen(command, input=None):
+    """Uses subprocess.Popen to execute <command>, piping <input> into stdin.
+    If command returns non-zero exitcode raise ExecError.
+    
+    Return command output.
+    """
+
+    shell=False
+    if isinstance(command, str):
+        shell=True
+
+    child = Popen(command, shell=shell, stdin=PIPE, stdout=PIPE, stderr=PIPE)
+
+    errstr = None
+    try:
+        outstr, errstr = child.communicate(input)
+    except OSError:
+        pass
+
+    errno = child.wait()
+    if errstr is None:
+        errstr = child.stderr.read()
+
+    if errno != 0:
+        raise ExecError(command, errno, errstr)
+
+    return outstr
-- 
